Tutorial Azioni Azioni Le azioni permettono di visualizzare informazioni ed elementi funzionali in-page senza dover richiedere un cambio di pagina da parte dell'utente. Le azioni sono gestite tramite il controller di Stimulus JS lato_action_controller. Per avviare un azione basta impostare l'attributo data-lato-action-target="trigger" ad un link del DOM e definire tramite l'attributo data-turbo-frame="id_frame" l'ID del turbo-frame da caricare nella azione. Esempio <%= link_to 'Esempio', main_app.products_path, data: { lato_action_target: 'trigger', turbo_frame: 'lato_index_default_product' } %> Personalizzare l'overlay Specificare il titolo Esempio <%= link_to 'Esempio', main_app.products_path, data: { lato_action_target: 'trigger', turbo_frame: 'lato_index_default_product', action_title: 'Titolo personalizzato' } %> Specificare la dimensione Esempio <%= link_to 'Esempio', main_app.products_path, data: { lato_action_target: 'trigger', turbo_frame: 'lato_index_default_product', action_size: 'xl' } %>
----------------------------------------
Tutorial Componenti Componenti Lato dispone di una serie di componenti funzionali riutilizzabili. Utilizzando le componenti di Lato √® possibile risparmiare tempo di lavoro e facilitare le attivit√† di manutenzione dell'applicazione. Tutte le componenti sono disponibili tramite l'helper Lato::ComponentsHelper. [Source code: Lato::ComponentsHelper](https://github.com/lato-org/lato/blob/main/app/helpers/lato/components_helper.rb) Navbar Navbar nav item Componente per renderizzare una voce di menu nella navbar. Parametri: - key: chiave della voce di menu. Utilizzata per attivare la voce di menu se impostata attiva tramite la funzione active_navbar del concern Lato::Layoutable. - path: path o url assoluto dove rimandare l'utente. - &block: blocco di HTML da renderizzare all'interno della voce di menu. <%= lato_navbar_nav_item :account, lato.account_path do %> Account <% end %> Sidebar Sidebar nav item Componente per renderizzare una voce di menu nella sidebar. Parametri: - key: chiave della voce di menu. Utilizzata per attivare la voce di menu se impostata attiva tramite la funzione active_sidebar del concern Lato::Layoutable. - path: path o url assoluto dove rimandare l'utente. - &block: blocco di HTML da renderizzare all'interno della voce di menu. <%= lato_sidebar_nav_item :account, lato.account_path do %> Account <% end %> Page Page head <%= lato_page_head 'Titolo pagina' %> <%= lato_page_head 'Titolo pagina', [{ label: 'Titolo 1', path: main_app.page_path }, { label: 'Titolo 2' }] %> <%= lato_page_head 'Titolo pagina' do %> <p class="lead">Benvenuto in questa pagina</p> <% end %> Form I form possono essere generati utilizzando le componenti lato_form. Le componenti lato_form sono una serie di componenti diverse programmate per essere utilizzate con l'helper Rails form_with e il controller Stimulus lato_form_controller. Di seguito la lista di componenti disponibili e un esempio di utilizzo: lato_form_notices visualizza il feedback positivo al salvataggio (notice impostati dalla action). lato_form_errors visualizza il feedback negativo al salvataggio (errori presenti nell'istanza del modello). lato_form_item_label visualizza la label dei campi. lato_form_item_input_text visualizza un input di testo. lato_form_item_input_email visualizza un input email. lato_form_item_input_password visualizza un input password. lato_form_item_input_check visualizza un input checkbox. lato_form_item_input_select visualizza un input select. lato_form_submit visualizza il pulsante di submit. <% user ||= @session.user %> <%= turbo_frame_tag 'tutorial_form-example' do %> <%= form_with model: user, url: main_app.components_update_user_action_path, data: { turbo_frame: '_self', controller: 'lato-form' } do |form| %> <%= lato_form_notices class: %w[mb-3] %> <%= lato_form_errors user, class: %w[mb-3] %> <div class="row"> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :first_name, 'Nome' %> <%= lato_form_item_input_text form, :first_name, required: true %> </div> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :last_name, 'Cognome' %> <%= lato_form_item_input_text form, :last_name, required: true %> </div> </div> <div class="row"> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :select, 'Select' %> <%= lato_form_item_input_select form, :select, [['Type 1', '1'], ['Type 2', '2']], required: true %> </div> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :file, 'File' %> <%= lato_form_item_input_file form, :file, required: true %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :textarea, 'Textarea' %> <%= lato_form_item_input_textarea form, :textarea, required: true %> </div> </div> <div class="row"> <div class="col col-12 col-lg-4 mb-3"> <%= lato_form_item_label form, :date, 'Date' %> <%= lato_form_item_input_date form, :date, required: true %> </div> <div class="col col-12 col-lg-4 mb-3"> <%= lato_form_item_label form, :datetime, 'Datetime' %> <%= lato_form_item_input_datetime form, :datetime, required: true %> </div> <div class="col col-12 col-lg-4 mb-3"> <%= lato_form_item_label form, :time, 'Time' %> <%= lato_form_item_input_time form, :time, required: true %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :color, 'Colore' %> <%= lato_form_item_input_color form, :color, required: true %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :first_name, 'Nome con autocompletamento' %> <%= lato_form_item_input_text form, :first_name, required: true, data: { controller: 'lato-input-autocomplete', lato_input_autocomplete_path_value: products_autocomplete_path } %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :first_name, 'Nome con autocompletamento V2' %> <%= lato_form_item_input_text form, :first_name, required: true, data: { controller: 'lato-input-autocomplete2', lato_input_autocomplete2_path_value: products_autocomplete_path } %> </div> </div> <div class="d-flex justify-content-end"> <%= lato_form_submit form, 'Aggiorna', class: %w[btn-success] %> </div> <% end %> <% end %> Index La componente lato_index permette di visualizzare facilmente i dati presenti in database. Index (front-end) Il modo pi√π semplice per utilizzare la componente √® quello di passargli una collezione di ActiveRecord come parametro: <%= lato_index Product.all.limit(5) %> Personalizzare le colonne Le colonne possono essere personalizzate attraverso il parametro :columns: <%= lato_index Product.all.limit(5), columns: %i[id code status] %> Note I titoli delle colonne possono essere modificati attraverso i file di traduzione di Rails. Esempio: it: activerecord: attributes: product: code: Codice status: Stato Personalizzare il contenuto delle colonne Il contenuto delle colonne pu√≤ essere personalizzato creando degli appositi helper con la sintassi model_column(member). Per esempio, per personalizzare l'output della colonna :lato_user_id √® stato creato il seguente helper in ProductsHelper: class ProductsHelper def product_lato_user_id(product) product.lato_user.full_name end end Aggiungere colonne custom Per aggiungere colonne custom ad una tabella basta specificare il nome del metodo dichiarato nel modello per fornire il dato corrispondente. Per esempio, dopo aver aggiunto il metodo lifetime al modello Product, √® possibile utilizzare la colonna :lifetime: class Product < ApplicationRecord # Helpers ## def lifetime Time.now - created_at end end class ProductsHelper def product_lifetime(product) Time.at(product.lifetime).utc.strftime('%H h %M m') end end <%= lato_index Product.all.limit(5), columns: %i[id code status lifetime] %> Note Anche le colonne custom possono essere tradotte dai file di traduzione di Rails proprio come le colonne realmente presenti in database. Per aggiungere eventuali colonne che non corrispondo ad attributi reali del prodotto √® possibile, invece di dichiarare una funzione nel modello, specificare la colonna con attr_accessor :nome_colonna: class Product < ApplicationRecord attr_accessor :lifetime end Aggiungere azioni <%= lato_index Product.all.limit(5), custom_actions: { create: { path: products_create_path, icon: 'bi bi-plus', aria_label: 'Crea prodotto', title: 'Crea prodotto' } } %> Aggiungere azioni in-page <%= lato_index Product.all.limit(5), custom_actions: { create: { path: products_create_path, icon: 'bi bi-plus', data: { lato_action_target: 'trigger', turbo_frame: dom_id(Product.new, 'form') }, aria_label: 'Crea prodotto', title: 'Crea prodotto' } } %> Note L'opzione :create_turbo_frame specifica l'ID del turbo-frame presente nella pagina products_create_path che deve essere inserito all'interno dell'overlay. Aggiungere azioni alle singole righe Le azioni sulle singole righe possono essere aggiunte attraverso l'aggiunta di colonne custom (come visto precedentemente). Anche le azioni sulle righe possono essere aperte in-page tramite overlay specificando gli attributi data-lato-index-target="action" e data-turbo-frame="ID-turbo-frame-da-caricare". class ProductsHelper def product_actions(product) content_tag(:div, class: 'btn-group btn-group-sm') do concat link_to( 'Modifica', products_update_path(product), class: 'btn btn-primary', data: { lato_action_target: 'trigger', turbo_frame: dom_id(product, 'form') } ) end end end <%= lato_index Product.all.limit(5), columns: %i[id code status lifetime actions] %> Index (back-end) Per rendere l'index completamente interattivo √® necessario utilizzare la funzione lato_index_collection del concern Lato::Componentable nel controller. def index @products = lato_index_collection(Product.all, pagination: true) end <%= lato_index @products %> Personalizzare le colonne def index @products_columns = lato_index_collection( Product.all, pagination: true, columns: %i[code status id] ) end <%= lato_index @products_columns %> Personalizzare il numero di elementi per pagina Il numero di elementi per pagina pu√≤ essere impostato dall'utente tramite un selettore con diversi opzioni. Il selettore pu√≤ essere attivato e personalizzato tramite il parametro :pagination_options della funzione lato_index_collection. def index @products_pagination_options = lato_index_collection( Product.all, pagination: 10, columns: %i[code status id], key: 'products_pagination_options' ) end <%= lato_index @products_pagination_options, pagination_options: [10,20,50,100] %> Rendere le colonne ordinabili def index @products_sortable_columns = lato_index_collection( Product.all, pagination: true, columns: %i[code status lato_user_id], sortable_columns: %i[code status lato_user_id] ) end <%= lato_index @products_sortable_columns %> Note Per personalizzare le regole di ordinamento √® possibile definire lo scope lato_index_order all'interno del modello. Esempio class Product < ApplicationRecord # Relations ## belongs_to :lato_user, class_name: 'Lato::User' # Scopes ## scope :lato_index_order, ->(column, order) do return joins(:lato_user).order("lato_users.last_name #{order}, lato_users.first_name #{order}") if column == :lato_user_id order("#{column} #{order}") end end Rendere le colonne ricercabili def index @products_searchable_columns = lato_index_collection( Product.all, pagination: true, columns: %i[code status lato_user_id], sortable_columns: %i[code status lato_user_id], searchable_columns: %i[code lato_user_id] ) end <%= lato_index @products_searchable_columns %> Note Per personalizzare le regole di ricerca √® possibile definire lo scope lato_index_search all'interno del modello. Esempio class Product < ApplicationRecord # Relations ## belongs_to :lato_user, class_name: 'Lato::User' # Scopes ## scope :lato_index_search, ->(search) do joins(:lato_user).where(" lower(code) LIKE :search OR lower(lato_users.first_name) LIKE :search OR lower(lato_users.last_name) LIKE :search ", search: "%#{search.downcase.strip}%") end end
----------------------------------------
Tutorial Configurazione Configurazione La configurazione di Lato √® gestita dalla classe Lato::Config e pu√≤ essere modificata tramite un apposito initializer. Per personalizzare la configurazione di default puoi creare un initializer √® inserire il codice seguente: Lato.configure do |config| config.application_title = 'Lato example app' config.session_root_path = :tutorial_path end [Source code: Esempio](https://github.com/lato-org/lato/blob/main/test/dummy/config/initializers/lato_config.rb) [Source code: Lato::Config](https://github.com/lato-org/lato/blob/main/lib/lato/config.rb) Configurazione applicazione Lato.configure do |config| config.application_title = 'Lato example app' # Titolo applicazione config.application_company_name = 'Lato Team' # Titolo azienda proprietaria dell'applicazione config.application_company_url = 'http://domain.com' # Url azienda proprietaria dell'applicazione end Configurazione autenticazione Lato.configure do |config| config.auth_disable_signup = true # Disabilita la possibilit√† di registrarsi autonomamente config.auth_disable_recover_password = true # Disabilita la possibilit√† di recuperare la password autonomamente config.auth_disable_web3 = true # Disabilita la possibilit√† di autenticarsi utilizzando un wallet web3 config.auth_disable_authenticator = true # Disabilita la possibilit√† di autenticarsi utilizzando google authenticator end Configurazione assets Lato.configure do |config| config.assets_stylesheet_entry = 'application' # Specifica il file CSS utilizzato per lo stile di lato (default application.scss) config.assets_importmap_entry = 'application' # Specifica il file JS base utilizzato per lo stile di lato (default application.js) end Configurazione gestione sessioni Lato.configure do |config| config.session_lifetime = 5.days # Tempo di vita dei cookie di sessione config.session_root_path = :tutorial_path # Nome della path dove rimandare l'utente una volta eseguito il login/signup end Configurazione email Lato.configure do |config| config.email_from = 'demo@mail.com' # Indirizzo email mittente delle notifiche email end Note La configurazione email_from pu√≤ essere impostata con la struttura " "Name" <example@domain.com>' ". Esempio: Lato.configure do |config| config.email_from = '"Company name" <demo@mail.com>' # Indirizzo email mittente delle notifiche email end Configurazione informazioni legali Lato.configure do |config| config.legal_privacy_policy_url = 'http:/domain.com/privacy' # Url privacy policy applicazione config.legal_privacy_policy_version = 32 # Intero che specifica la versione di privacy policy attiva config.legal_terms_and_conditions_url = 'http:/domain.com/terms' # Url termini e condizioni applicazione config.legal_terms_and_conditions_version = 32 # Intero che specifica la versione di termini e condizioni attiva end Note Lato tiene traccia della versione di privacy policy e termini e condizioni accettate dall'utente. Se l'utente loggato risulta aver accettato una versione inferiore a quella impostata tramite legal_privacy_policy_version o legal_terms_and_conditions_version allora vedr√† automaticamente una richiesta di accettazione delle nuove policy nella pagina di gestione account. Per verificare se un utente ha accettato le ultime versioni di policy √® possibile utilizzare i metodi valid_accepted_privacy_policy_version? e valid_accepted_terms_and_conditions_version? delle istanze del modello Lato::User. Esempio: user = Lato::User.all.first throw "Privacy policy non valida" unless user.valid_accepted_privacy_policy_version? throw "Termini e condizioni non validi" unless user.valid_accepted_terms_and_conditions_version? Configurazione connessioni account Lato.configure do |config| config.web3_connection = true # Permette all'utente di collegare un wallet web3 al proprio account config.authenticator_connection = true # Permette all'utente di collegare google authenticator al proprio account end [Source code: Lato::User](https://github.com/lato-org/lato/blob/main/app/models/lato/user.rb)
----------------------------------------
Tutorial Personalizzazione Personalizzazione La personalizzazione di Lato pu√≤ avvenire in diversi modi: Configura le classi del layout di Bootstrap tramite la classe Lato::Btstrap; Personalizza il comportamento delle componenti del layout tramite il concern Lato::Layoutable; Aggiorna il contenuto del layout tramite i content partials; Modifica il CSS di specifiche pagine tramite le classi del body. Configurazione classi layout Attraverso la classe Lato::Btstrap √® possibile personalizzare le classi di Bootstrap utilizzate da Lato per gli elementi grafici del layout. Gli elementi grafici che compongono il layout sono: navbar, content, sidebar e footer. Per personalizzare le classi di default puoi creare un initializer √® inserire il codice seguente: Lato.bootstrap do |btstrap| btstrap.navbar = 'navbar-light navbar-expand-lg fixed-top bg-light shadow-sm px-3' btstrap.navbar_container = 'container-fluid' btstrap.navbar_collapse = 'justify-content-end' btstrap.sidebar = 'sidebar' btstrap.content = 'p-3' btstrap.content_container = 'container-fluid' btstrap.footer = 'bg-light px-3 py-2' btstrap.footer_container = 'container-fluid' end [Source code: Esempio](https://github.com/lato-org/lato/blob/main/test/dummy/config/initializers/lato_bootstrap.rb) [Source code: Lato::Btstrap](https://github.com/lato-org/lato/blob/main/lib/lato/btstrap.rb) Personalizzazione comportamento layout Il comportamento del layout di Lato pu√≤ essere personalizzato tramite le funzioni messe a disposizione dal concern Lato::Layoutable. Il concern disponde di una serie di funzioni utili. Di seguito un esempio: class TutorialController < ApplicationController def index hide_sidebar # nasconde la sidebar show_sidebar # visualizza la sidebar active_sidebar(:tutorial) # imposta l'active sulla voce della sidebar con chiave :tutorial active_navbar(:tutorial) # imposta l'active sulla voce della navbar con chiave :tutorial page_title('Custom title') # imposta il titolo della pagina page_class('custom-class') # aggiunge una classe nel body della pagina end end Note Tutte le funzioni di Lato::Layoutable possono essere anche utilizzate tramite i before_action dei controller. [Source code: Lato::Layoutable](https://github.com/lato-org/lato/blob/main/app/controllers/concerns/lato/layoutable.rb) Aggiornamento contenuto layout La maggior parte dei contenuti del layout di lato sono impostati tramite appositi parziali chiamati attraverso la sintassi _nome-parziale_content.html.erb. Per personalizzare il contenuto di queste componenti puoi sovrascrivere il parziale e modificarlo a piacimento. Questi tipi di parziali sono automaticamente caricati nell'applicazione principale attraverso il comando rails lato:install:application. Note Lo stesso uso di parziali √® applicato anche per i template della mail (vedi _mailer-head_content.html.erb e _mailer-foot_content.html.erb). [Source code: directory con i vari parziali](https://github.com/lato-org/lato/tree/main/app/views/layouts/lato) Modifica CSS pagine Per facilitare l'impostazione di regole CSS per specifiche pagine puoi utilizzare le classi applicate al body. Il body contiene sempre due classi che specificano il controller e la action che lo renderizzando. Se, per esempio, abbiamo la action tutorial dentro il controller HelpController, allora il body avr√† le classi: .controller-help .action-tutorial Nice to have Impostare una terza classe con il nome del template HTML utilizzato per gestire template renderizzati da action diverse.
----------------------------------------
Tutorial Guida Guida La guida pu√≤ essere utilizzata per costruire dei tutorial passo a passo di utilizzo della piattaforma. Le guide sono gestite tramite il controller di Stimulus JS lato_guide_controller. Per aggiungere una guida impostare l'attributo data-lato-guide-target="item" ad un elemento del DOM e definire tramite l'attributo data-guide-key una chiave univoca per la guida, data-guide-index l'indice di visualizzazione e data-guide-content il contenuto della guida. <p data-lato-guide-target="item" data-guide-key="intro" data-guide-index="1" data-guide-content="Questo √® un esempio di una guida." > Reset delle guide Una volta che una guida √® stata visualizzata, questa viene memorizzata nel local storage del browser. Per resettare le guide basta utilizzare il metodo rerun del controller lato_guide_controller. Reset <%= link_to 'Reset', '#', data: { action: 'click->lato-guide#rerun' } %>
----------------------------------------
Benvenuto su Lato Questa √® la homepage dell'applicazione. Una breve guida su come personalizzare un nuovo progetto. Queste pagine sono state generate scaricando i template HTML renderizzati dalla dummy app di Lato. Alcune funzionalit√† potrebbero non essere disponibili. Per utilizzare la documentazione completa √® necessario eseguire la gemma in locale attraverso i seguenti comandi: $ git clone https://github.com/lato-org/lato $ cd lato $ bundle $ rails db:migrate $ rails db:seed $ foreman start -f Procfile.dev Come iniziare Per creare delle pagine custom di presentazione del progetto puoi modificare l' ApplicationController estendendo la classe Lato::ApplicationController e specificando di utilizzare il layout di Lato: class ApplicationController < Lato::ApplicationController layout 'lato/application' def index; end end [Source code: Esempio](https://github.com/lato-org/lato/blob/main/test/dummy/app/controllers/application_controller.rb) [Source code: Lato::ApplicationController](https://github.com/lato-org/lato/blob/main/app/controllers/lato/application_controller.rb) Come nascondere la sidebar Per nascondere la sidebar puoi utilizzare utilizzare uno dei metodi messi a disposizione dal concern Lato::Layoutable (gi√† importato da Lato::ApplicationController): class ApplicationController < Lato::ApplicationController layout 'lato/application' def index hide_sidebar end end Per applicare la regola su tutte le action del controller puoi utilizzare rapidamente il before_action: class ApplicationController < Lato::ApplicationController layout 'lato/application' before_action :hide_sidebar def index; end def other_action; end end [Source code Lato::Layoutable](https://github.com/lato-org/lato/blob/main/app/controllers/concerns/lato/layoutable.rb) Come utilizzare del CSS custom e personalizzare Bootstrap Per personalizzare il CSS di Lato puoi modificare il file application.scss dell'applicazione principale: @import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap'); // Override bootstrap variables $font-family-base: 'Lato' !default; $primary: #03256C; // Import lato css @import 'lato/application'; // Add custom css pre { border-radius: 15px; } [Source code: Esempio](https://github.com/lato-org/lato/blob/main/test/dummy/app/assets/stylesheets/application.scss) [Source code: Variabili SCSS Bootstrap](https://github.com/twbs/bootstrap/blob/main/scss/_variables.scss) Come utilizzare dei controller di Stimulus JS custom Stimulus JS √® una dipendenza di Lato e pu√≤ essere utilizzata normalmente senza integrazioni specifiche. Di seguito trovi un esempio di utilizzo di un controller custom hello_controller.js e di un controller di lato lato_hello_controller.js: Note Tutti i controller gestiti da Lato hanno, per definizione, il nome lato_nome_controller.js. Esempio: lato_hello_controller.js viene utilizzato con l'attributo data-controller="lato_hello". Prosegui
----------------------------------------
Tutorial Inviti Inviti Gli inviti possono essere utilizzati per le applicazioni che non prevedono la registrazione ma permettono agli utenti di invitare nella piattaforma altri utenti. Attraverso un invito √® possibile: Inviare una mail di invito all'utente con cui impostare le proprie credenziali Tenere traccia delle registrazioni avvenute Di seguito esempi delle operazioni che √® possibile eseguire con gli inviti: # creazione di un invito (e invio automatico della mail) @invitation = Lato::Invitation.create(params.require(:invitation).permit(:email).merge(inviter_lato_user_id: @session.user_id)) # re-invio della mail di invito (max 1 ogni 2 minuti) @invitation.send_invite # eliminazione dell'invito @invitation.destroy
----------------------------------------
Tutorial Operazioni Operazioni Le operazioni sono un sistema di Lato per gestire visualmente l'esecuzione di Job in background. Le operazioni sono gestite da diverse parti: Il modello Lato::Operation inizializza tutte le operazioni e tiene traccia del loro stato di esecuzione. Il controller Lato::OperationsController gestisce l'accesso degli utenti ad una operazione in corso. La componente lato_operation permette di visualizzare a front-end lo stato di una operazione. Convertire un Job in una operazione Il metodo pi√π facile per convertire un Job in una operazione √®, semplicemente, fare in modo che il Job sia una sotto-classe di Lato::ApplicationJob. √à inoltre necessario che il metodo perform() riceva un solo parametro Hash params. # Prima def MyJob < ApplicationJob def perform(hello) puts hello end end # Dopo def MyJob < Lato::ApplicationJob def perform(params = {}) puts params['hello'] end end Generare una operazione Le operazioni possono essere generate tramite il metodo generate del modello Lato::Operation. La generazione di un'operazione richiede tre parametri: nome del job da eseguire, Hash dei parametri da passare, id dell'utente che ha richiesto la generazione. operation = Lato::Operation.generate('ExportProductsJob', { product_ids: [1, 2, 3] }, @session.user_id) Una volta generata l'operazione deve essere eseguita attraverso il metodo start. Di seguito un esempio di controller che avvia una operazione: class CustomController < ApplicationController def create_operation_action @operation = Lato::Operation.generate('OperationExampleJob', {}, @session.user_id) respond_to do |format| if @operation.start format.html { redirect_to lato.operation_path(@operation) } format.json { render json: @operation } else format.html { render :index, status: :unprocessable_entity } format.json { render json: @operation.errors, status: :unprocessable_entity } end end end end Mostrare l'esito di una operazione Ogni operazione pu√≤ essere visualizzata nella route lato.operation_path(operation_id). Per garantire la sicurezza dei dati un'operazione √® accessibile solo per l'utente che ne ha richiesto la generazione. Ogni operazione pu√≤ avere 4 stati: created, running, completed, failed. La visualizzazione di una operazione, gestita tramite la componente lato_operation, mostra in real-time lo stato in cui si trova l'operazione e il relativo output. Utilizza il link di seguito per provare una operazione: <%= link_to 'Genera operazione', main_app.custom_create_operation_action_path, data: { turbo_method: :post } %> Genera operazione Note Per visualizzare l'esito di una operazione direttamente in-page √® possibile utilizzare le funzionalit√† di lato_action_controller. Esempio: <%= link_to 'Genera operazione', main_app.custom_create_operation_action_path, data: { lato_action_target: 'trigger', turbo_method: :post, turbo_frame: 'lato_operation' } %> Genera operazione con successo Gestire gli output di una operazione Gli output di una operazione possono essere gestiti direttamente all'interno del Job che la esegue tramite una serie di funzioni. Tutte le funzioni per gestire l'output di una operazione possono essere chiamate anche se il Job viene eseguito normalmente (senza utilizzare il modello Lato::Operation). Specificare un messaggio di output Genera operazione class MyJob < Lato::ApplicationJob def perform(params = {}) save_operation_output_message("Messaggio di successo dell'operazione") end end Specificare un file di output Genera operazione class MyJob < Lato::ApplicationJob def perform(params = {}) file_path = Rails.root.join('tmp', 'myfile.csv') save_operation_output_file(file_path) end end Specificare un errore Genera operazione class MyJob < Lato::ApplicationJob def perform(params = {}) raise "Messaggio di errore dell'operazione" end end Aggiornare la percentuale di avanzamento Genera operazione class MyJob < Lato::ApplicationJob def perform(params = {}) 10.times do |index| sleep(1) update_operation_percentage((index + 1) * 10) end end end Specificare un file di input <%= form_with url: create_operation_action_path(type: 'file_input'), data: { lato_action_target: 'triggerSubmit', turbo_frame: 'lato_operation', controller: 'lato-form' } do |form| %> ... class CustomController < ApplicationController def create_operation_action @operation = Lato::Operation.generate('OperationExampleJob', {}, @session.user_id, params[:file]) # ... end end class MyJob < Lato::ApplicationJob def perform(params = {}) save_operation_output_message("Hai caricato il file #{operation_input_file_attachment.filename}") end end
----------------------------------------
Tutorial Tutorial üëã Admin, benvenuto nel tutorial di Lato! Come proteggere una pagina Per autenticare una pagina in modo da non renderla pubblica per utenti non registrati puoi utilizzare uno dei metodi messi a dispozione dal concern Lato::Sessionable (gi√† importato da Lato::ApplicationController): class TutorialController < ApplicationController def index return unless authenticate_session end end Per applicare la regola su tutte le action del controller puoi utilizzare rapidamente il before_action: class TutorialController < ApplicationController before_action :authenticate_session def index; end end Note Proprio come authenticate_session puoi anche utilizzare il contrario not_authenticate_session per nascondere una pagina agli utenti registrati. Esempio: class AuthenticationController < ApplicationController before_action :not_authenticate_session, only: %i[signin] before_action :authenticate_session, only: %i[signout] def signin; end def signout; end end Limitare il numero di richieste Per limitare il numero di richieste di una pagina puoi utilizzare il metodo limit_request: class TutorialController < ApplicationController before_action :authenticate_session before_action :limit_request, only: %i[index] def index; end end Il metodo limit_request accetta due parametri: limit (default: 10) e time_window (default: 10.minutes). I due parametri specificano il numero di richieste massime che un utente pu√≤ effettuare in un determinato lasso di tempo. [Source code Lato::Sessionable](https://github.com/lato-org/lato/blob/main/app/controllers/concerns/lato/sessionable.rb) Accedere all'utente loggato L'utente che ha effettuato l'accesso a Lato √® sempre disponibile in tutti i controller e tutte le view tramite l'istanza @session del modello Lato::Session: class TutorialController < ApplicationController # ... def index @user_id = @session.user_id @user = @session.user.first_name end # ... end Note Utilizzando @session.user_id al posto di @session.user.id √® possibile evitare di eseguire query nella tabella utenti ottimizzando i tempi di risposta! @session.valid? permette di verificare se l'utente √® loggato o meno. [Source code Lato::Session](https://github.com/lato-org/lato/blob/main/app/models/lato/session.rb)
----------------------------------------
