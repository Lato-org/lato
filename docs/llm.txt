Tutorial Actions Actions Actions allow you to display information and functional elements in-page without requiring a full page reload by the user. They are managed via the Stimulus JS controller lato_action_controller. To trigger an action, simply add the attribute data-lato-action-target="trigger" to a link in the DOM and define the ID of the turbo-frame to load using the data-turbo-frame="frame_id" attribute. <%= link_to 'Example', main_app.products_path, data: { lato_action_target: 'trigger', turbo_frame: 'lato_index_default_product' } %> Customizing the Overlay Set a Custom Title <%= link_to 'Example', main_app.products_path, data: { lato_action_target: 'trigger', turbo_frame: 'lato_index_default_product', action_title: 'Custom Title' } %> Set a Custom Size <%= link_to 'Example', main_app.products_path, data: { lato_action_target: 'trigger', turbo_frame: 'lato_index_default_product', action_size: 'xl' } %>
----------------------------------------
Tutorial Components Components Lato provides a set of reusable functional components. By using Lato components, you can save development time and simplify maintenance tasks. All components are available via the Lato::ComponentsHelper helper. Navbar Navbar nav item Component to render a menu item in the navbar. Parameters: - key: the menu item's key. Used to activate the item via the active_navbar function from the Lato::Layoutable concern. - path: a path or absolute URL to redirect the user. - &block: block of HTML to render inside the menu item. <%= lato_navbar_nav_item :account, lato.account_path do %> Account <% end %> Sidebar Sidebar nav item Component to render a menu item in the sidebar. Parameters: - key: the menu item's key. Used to activate the item via the active_sidebar function from the Lato::Layoutable concern. - path: a path or absolute URL to redirect the user. - &block: block of HTML to render inside the menu item. <%= lato_sidebar_nav_item :account, lato.account_path do %> Account <% end %> Page Page head <%= lato_page_head 'Page title' %> <%= lato_page_head 'Page title', [{ label: 'Title 1', path: main_app.page_path }, { label: 'Title 2' }] %> <%= lato_page_head 'Page title' do %> <p class="lead">Welcome to this page</p> <% end %> Form Forms can be generated using the lato_form components. lato_form components are a set of utilities designed to work with Rails' form_with helper and the Stimulus controller lato_form_controller. Below is a list of available components with usage examples: lato_form_notices displays success feedback (notices set by the controller action). lato_form_errors displays error feedback (based on model instance errors). lato_form_item_label renders the field label. lato_form_item_input_text renders a text input. lato_form_item_input_number renders a number input. lato_form_item_input_email renders an email input. lato_form_item_input_password renders a password input. lato_form_item_input_check renders a checkbox input. lato_form_item_input_select renders a select input. lato_form_item_input_file renders a file input. lato_form_item_input_textarea renders a textarea input. lato_form_item_input_date renders a date input. lato_form_item_input_datetime renders a datetime input. lato_form_item_input_time renders a time input. lato_form_item_input_color renders a color input. lato_form_submit renders the submit button. <% user ||= @session.user %> <%= turbo_frame_tag 'tutorial_form-example' do %> <%= form_with model: user, url: main_app.components_update_user_action_path, data: { turbo_frame: '_self', controller: 'lato-form' } do |form| %> <%= lato_form_notices class: %w[mb-3] %> <%= lato_form_errors user, class: %w[mb-3] %> <div class="row"> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :first_name, 'Name' %> <%= lato_form_item_input_text form, :first_name, required: true %> </div> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :last_name, 'Surname' %> <%= lato_form_item_input_text form, :last_name, required: true %> </div> </div> <div class="row"> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :select, 'Select' %> <%= lato_form_item_input_select form, :select, [['Type 1', '1'], ['Type 2', '2']], required: true %> </div> <div class="col col-12 col-lg-6 mb-3"> <%= lato_form_item_label form, :file, 'File' %> <%= lato_form_item_input_file form, :file, required: true %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :textarea, 'Textarea' %> <%= lato_form_item_input_textarea form, :textarea, required: true %> </div> </div> <div class="row"> <div class="col col-12 col-lg-4 mb-3"> <%= lato_form_item_label form, :date, 'Date' %> <%= lato_form_item_input_date form, :date, required: true %> </div> <div class="col col-12 col-lg-4 mb-3"> <%= lato_form_item_label form, :datetime, 'Datetime' %> <%= lato_form_item_input_datetime form, :datetime, required: true %> </div> <div class="col col-12 col-lg-4 mb-3"> <%= lato_form_item_label form, :time, 'Time' %> <%= lato_form_item_input_time form, :time, required: true %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :color, 'Color' %> <%= lato_form_item_input_color form, :color, required: true %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :first_name, 'Name with auto-complete' %> <%= lato_form_item_input_text form, :first_name, required: true, data: { controller: 'lato-input-autocomplete', lato_input_autocomplete_path_value: products_autocomplete_path } %> </div> </div> <div class="row"> <div class="col col-12 mb-3"> <%= lato_form_item_label form, :first_name, 'Name with auto-complete V2' %> <%= lato_form_item_input_text form, :first_name, required: true, data: { controller: 'lato-input-autocomplete2', lato_input_autocomplete2_path_value: products_autocomplete_path } %> </div> </div> <div class="d-flex justify-content-end"> <%= lato_form_submit form, 'Update', class: %w[btn-success] %> </div> <% end %> <% end %> Index The lato_index component allows easy visualization of database records. Index (front-end) The simplest way to use the component is to pass it an ActiveRecord collection: <%= lato_index Product.all.limit(5) %> Customizing columns Columns can be customized using the :columns parameter: <%= lato_index Product.all.limit(5), columns: %i[id code status] %> Notes Column titles can be customized using Rails translation files. Example: en: activerecord: attributes: product: code: Code status: Status Customizing column content You can customize column content by creating helper methods with the format model_column(record). For example, to customize the output of the :lato_user_id column, define the following helper in ProductsHelper: class ProductsHelper def product_lato_user_id(product) product.lato_user.full_name end end Adding custom columns To add custom columns, declare a method in the model that provides the value. For example, after adding a lifetime method to the Product model, you can use the :lifetime column: class Product < ApplicationRecord def lifetime Time.now - created_at end end class ProductsHelper def product_lifetime(product) Time.at(product.lifetime).utc.strftime('%H h %M m') end end <%= lato_index Product.all.limit(5), columns: %i[id code status lifetime] %> Notes Custom columns can also be translated using Rails translation files, just like database-backed columns. To add columns that don't map to real attributes, use attr_accessor :column_name instead of defining a method in the model: class Product < ApplicationRecord attr_accessor :lifetime end Adding actions <%= lato_index Product.all.limit(5), custom_actions: { create: { path: products_create_path, icon: 'bi bi-plus', aria_label: 'Create product', title: 'Create product' } } %> Adding in-page actions <%= lato_index Product.all.limit(5), custom_actions: { create: { path: products_create_path, icon: 'bi bi-plus', data: { lato_action_target: 'trigger', turbo_frame: dom_id(Product.new, 'form') }, aria_label: 'Create product', title: 'Create product' } } %> Notes The :create_turbo_frame option specifies the turbo-frame ID in the products_create_path page that should be inserted into the overlay. Adding row-specific actions Row-specific actions can be added through custom columns (as shown above). These actions can also be opened in-page via overlays using data-lato-index-target="action" and data-turbo-frame="turbo-frame-ID". class ProductsHelper def product_actions(product) content_tag(:div, class: 'btn-group btn-group-sm') do concat link_to( 'Edit', products_update_path(product), class: 'btn btn-primary', data: { lato_action_target: 'trigger', turbo_frame: dom_id(product, 'form') } ) end end end <%= lato_index Product.all.limit(5), columns: %i[id code status lifetime actions] %> Index (back-end) To make the index fully interactive, use the lato_index_collection function from the Lato::Componentable concern in the controller. def index @products = lato_index_collection(Product.all, pagination: true) end <%= lato_index @products %> Customizing columns def index @products_columns = lato_index_collection( Product.all, pagination: true, columns: %i[code status id] ) end <%= lato_index @products_columns %> Customizing pagination size Users can choose how many items to display per page using a selector enabled via the :pagination_options parameter in lato_index_collection. def index @products_pagination_options = lato_index_collection( Product.all, pagination: 10, columns: %i[code status id], key: 'products_pagination_options' ) end <%= lato_index @products_pagination_options, pagination_options: [10,20,50,100] %> Making columns sortable def index @products_sortable_columns = lato_index_collection( Product.all, pagination: true, columns: %i[code status lato_user_id], sortable_columns: %i[code status lato_user_id] ) end <%= lato_index @products_sortable_columns %> Notes To customize sorting logic, define the lato_index_order scope inside the model. Example: class Product < ApplicationRecord belongs_to :lato_user, class_name: 'Lato::User' scope :lato_index_order, ->(column, order) do return joins(:lato_user).order("lato_users.last_name #{order}, lato_users.first_name #{order}") if column == :lato_user_id order("#{column} #{order}") end end Notes To set a default sorting column, use the default_sort_by option in the lato_index_collection method. Example: def index @products_default_sort = lato_index_collection( Product.all, pagination: true, columns: %i[code status lato_user_id], sortable_columns: %i[code status lato_user_id], default_sort_by: 'code|asc' # 'column|direction' ) end Making columns searchable def index @products_searchable_columns = lato_index_collection( Product.all, pagination: true, columns: %i[code status lato_user_id], sortable_columns: %i[code status lato_user_id], searchable_columns: %i[code lato_user_id] ) end <%= lato_index @products_searchable_columns %> Notes To customize search logic, define the lato_index_search scope inside the model. Example: class Product < ApplicationRecord belongs_to :lato_user, class_name: 'Lato::User' scope :lato_index_search, ->(search) do joins(:lato_user).where(" lower(code) LIKE :search OR lower(lato_users.first_name) LIKE :search OR lower(lato_users.last_name) LIKE :search ", search: "%#{search.downcase.strip}%") end end Skip total count for large tables For large tables, you can skip the total count to improve performance by setting the :skip_total_count option to true in the lato_index method. This is useful when you don't need the total count of records, such as when displaying a large collection. <%= lato_index @products_skip_total_count_columns, skip_total_count: true %>
----------------------------------------
Tutorial Configuration Configuration Lato's configuration is managed by the Lato::Config class and can be customized through a dedicated initializer. To override the default settings, create an initializer and add the following code: Lato.configure do |config| config.application_title = 'Lato example app' config.session_root_path = :tutorial_path end Application Configuration Lato.configure do |config| config.application_title = 'Lato example app' # Application title config.application_company_name = 'Lato Team' # Name of the owning company config.application_company_url = 'http://domain.com' # URL of the owning company end Authentication Configuration Lato.configure do |config| config.auth_disable_signup = true # Disable user self-signup config.auth_disable_recover_password = true # Disable password recovery config.auth_disable_web3 = true # Disable Web3 wallet login config.auth_disable_authenticator = true # Disable Google Authenticator login end Assets Configuration Lato.configure do |config| config.assets_stylesheet_entry = 'application' # CSS file for Lato styling (default: application.scss) config.assets_importmap_entry = 'application' # JS entry point for Lato (default: application.js) end Session Management Configuration Lato.configure do |config| config.session_lifetime = 5.days # Lifetime of session cookies config.session_root_path = :tutorial_path # Path to redirect users after login/signup end Email Configuration Lato.configure do |config| config.email_from = 'demo@mail.com' # Sender email address for notifications end Note The email_from setting can include a display name using the format "Name" <example@domain.com>. Example: Lato.configure do |config| config.email_from = '"Company name" <demo@mail.com>' end Legal Information Configuration Lato.configure do |config| config.legal_privacy_policy_url = 'http:/domain.com/privacy' # Privacy policy URL config.legal_privacy_policy_version = 32 # Version number of the active privacy policy config.legal_terms_and_conditions_url = 'http:/domain.com/terms' # Terms and conditions URL config.legal_terms_and_conditions_version = 32 # Version number of the active terms and conditions end Note Lato tracks which version of the privacy policy and terms the user has accepted. If the logged-in user has accepted a version lower than the one configured via legal_privacy_policy_version or legal_terms_and_conditions_version, a prompt will appear in the account management page to accept the new policies. To check whether a user has accepted the latest policy versions, use the valid_accepted_privacy_policy_version? and valid_accepted_terms_and_conditions_version? methods on instances of the Lato::User model. Example: user = Lato::User.all.first throw "Privacy policy not accepted" unless user.valid_accepted_privacy_policy_version? throw "Terms and conditions not accepted" unless user.valid_accepted_terms_and_conditions_version? Account Connection Configuration Lato.configure do |config| config.web3_connection = true # Allow users to link a Web3 wallet to their account config.authenticator_connection = true # Allow users to link Google Authenticator to their account end
----------------------------------------
Tutorial Customization Customization Lato can be customized in several ways: Configure Bootstrap layout classes using the Lato::Btstrap class; Customize layout behavior via the Lato::Layoutable concern; Update layout content using content partials; Modify page-specific CSS using body classes. Layout Class Configuration With the Lato::Btstrap class, you can customize the Bootstrap classes used by Lato for the layout’s UI components. The layout is composed of the following UI elements: navbar, content, sidebar, and footer. To override the default classes, you can create an initializer with the following code: Lato.bootstrap do |btstrap| btstrap.navbar = 'navbar-light navbar-expand-lg fixed-top bg-light shadow-sm px-3' btstrap.navbar_container = 'container-fluid' btstrap.navbar_collapse = 'justify-content-end' btstrap.sidebar = 'sidebar' btstrap.content = 'p-3' btstrap.content_container = 'container-fluid' btstrap.footer = 'bg-light px-3 py-2' btstrap.footer_container = 'container-fluid' end Layout Behavior Customization Lato’s layout behavior can be customized using methods provided by the Lato::Layoutable concern. This concern offers a set of useful functions. Here’s an example: class TutorialController < ApplicationController def index hide_sidebar # hides the sidebar show_sidebar # shows the sidebar active_sidebar(:tutorial) # sets active state on sidebar item with key :tutorial active_navbar(:tutorial) # sets active state on navbar item with key :tutorial page_title('Custom title') # sets the page title page_class('custom-class') # adds a CSS class to the body element end end Note All Lato::Layoutable methods can also be used inside controller before_action callbacks. Layout Content Customization Most layout content in Lato is defined via specific partials following the naming convention _partial-name_content.html.erb. To customize these layout parts, override and edit the partials as desired. These partials are automatically loaded into the main application via the rails lato:install:application command. Note This same partial-based approach is used for email templates (see _mailer-head_content.html.erb and _mailer-foot_content.html.erb). Page CSS Customization To easily apply custom CSS rules to specific pages, you can use the classes applied to the <body> tag. The body always includes two classes that identify the controller and the action rendering the view. For example, if you have an tutorial action inside the HelpController, the body will have the classes: .controller-help .action-tutorial
----------------------------------------
Tutorial Guide Guide The guide can be used to build step-by-step tutorials for using the platform. Guides are managed via the Stimulus JS controller lato_guide_controller. To add a guide, set the attribute data-lato-guide-target="item" to a DOM element and define a unique key for the guide with the data-guide-key attribute, the display index with data-guide-index, and the guide content with data-guide-content. <p data-lato-guide-target="item" data-guide-key="intro" data-guide-index="1" data-guide-content="This is an example of a guide." > Reset Guides Once a guide has been displayed, it is stored in the browser's local storage. To reset the guides, simply use the rerun method of the lato_guide_controller. <%= link_to 'Reset', '#', data: { action: 'click->lato-guide#rerun' } %>
----------------------------------------
This gem includes: User Management Full authentication system with signin, signup, password recovery, email validation, Google Authenticator MFA, and ETH wallet connection. Modern UI Web interface built with Bootstrap and Bootstrap Icons, featuring integrated UI components like data tables, forms, and modals. Stack Agnostic Works with different databases (PostgreSQL, MySQL, SQLite), job processors (Solid queue, Sidekiq, Delayed Job), and cache systems. Customizable & Extendable The gem is designed to be easily customizable and extendable. You can fully customize the UI and functionalities, add new features to your main application, or develop new engines to extend the panel. Modern Rails Features Ready to use with the latest Rails 7+ features like ESM import maps, Turbo and Stimulus. The front-end is responsive, mobile friendly and accessible. Installation Add Dependencies Add required dependencies to your application's Gemfile: # Use JavaScript with ESM import maps [https://github.com/rails/importmap-rails] gem "importmap-rails" # NOTE: Probably already installed in default rails 7+ project # Hotwire's SPA-like page accelerator [https://turbo.hotwired.dev] gem "turbo-rails" # NOTE: Probably already installed in default rails 7+ project # Hotwire's modest JavaScript framework [https://stimulus.hotwired.dev] gem "stimulus-rails" # NOTE: Probably already installed in default rails 7+ project # Use Sass to process CSS gem "sassc-rails" # Use lato as application panel gem "lato" Install and Setup Install gem and run required tasks: $ bundle $ rails active_storage:install $ rails lato:install:application $ rails lato:install:migrations $ rails db:migrate Configure Routes Mount lato routes on the config/routes.rb file: Rails.application.routes.draw do mount Lato::Engine => "/lato" # .... end Import Styles Import Lato Scss on app/assets/stylesheets/application.scss file: @import 'lato/application'; // .... Import JavaScript Import Lato Js on app/javascript/application.js file: import "lato/application"; // .... Setup I18n Setup I18n on the config/application.rb file: module MyApplication class Application < Rails::Application config.i18n.available_locales = [:it, :en] config.i18n.default_locale = :it # ... end end Get Started with Tutorial
----------------------------------------
Tutorial Invitations Invitations Invitations can be used for applications that do not require registration but allow users to invite others to the platform. Through an invitation, it is possible to: Send an invitation email to the user to set up their credentials Track completed registrations Here are some examples of the operations you can perform with invitations: # creating an invitation (and automatically sending the invite email) @invitation = Lato::Invitation.create(params.require(:invitation).permit(:email).merge(inviter_lato_user_id: @session.user_id)) # re-sending the invitation email (max 1 every 2 minutes) @invitation.send_invite # deleting the invitation @invitation.destroy
----------------------------------------
Tutorial Operations Operations Operations are Lato's system for visually managing the execution of background Jobs. Operations are handled by several components: The Lato::Operation model initializes all operations and tracks their execution state. The Lato::OperationsController controller manages user access to an ongoing operation. The lato_operation component allows displaying the operation status in the front-end. Converting a Job into an Operation The easiest way to convert a Job into an operation is to simply make the Job a subclass of Lato::ApplicationJob. Additionally, the perform() method must accept a single Hash parameter called params. # Before def MyJob < ApplicationJob def perform(hello) puts hello end end # After def MyJob < Lato::ApplicationJob def perform(params = {}) puts params['hello'] end end Generating an Operation Operations can be generated using the generate method of the Lato::Operation model. Creating an operation requires three parameters: the name of the job to execute, a Hash of parameters to pass, and the ID of the user requesting the operation. operation = Lato::Operation.generate('ExportProductsJob', { product_ids: [1, 2, 3] }, @session.user_id) Once generated, the operation must be started using the start method. Here is an example controller that starts an operation: class CustomController < ApplicationController def create_operation_action @operation = Lato::Operation.generate('OperationExampleJob', {}, @session.user_id) respond_to do |format| if @operation.start format.html { redirect_to lato.operation_path(@operation) } format.json { render json: @operation } else format.html { render :index, status: :unprocessable_entity } format.json { render json: @operation.errors, status: :unprocessable_entity } end end end end Displaying the Outcome of an Operation Each operation can be viewed at the route lato.operation_path(operation_id). To ensure data security, an operation is only accessible to the user who initiated it. Each operation can have four states: created, running, completed, failed. The operation view, handled via the lato_operation component, shows the real-time status and output of the operation. Use the link below to try out an operation: <%= link_to 'Generate Operation', main_app.custom_create_operation_action_path, data: { turbo_method: :post } %> Notes To display the result of an operation directly in-page, you can use lato_action_controller features. Example: <%= link_to 'Generate Operation', main_app.custom_create_operation_action_path, data: { lato_action_target: 'trigger', turbo_method: :post, turbo_frame: 'lato_operation' } %> Handling Operation Outputs An operation's output can be handled directly within the Job using a series of helper methods. These functions can also be called even if the Job is executed without using the Lato::Operation model. Set an Output Message class MyJob < Lato::ApplicationJob def perform(params = {}) save_operation_output_message("Operation succeeded with this message") end end Set an Output File class MyJob < Lato::ApplicationJob def perform(params = {}) file_path = Rails.root.join('tmp', 'myfile.csv') save_operation_output_file(file_path) end end Set an Error class MyJob < Lato::ApplicationJob def perform(params = {}) raise "This is the operation error message" end end Update Progress Percentage class MyJob < Lato::ApplicationJob def perform(params = {}) 10.times do |index| sleep(1) update_operation_percentage((index + 1) * 10) end end end Set an Input File <%= form_with url: create_operation_action_path(type: 'file_input'), data: { lato_action_target: 'triggerSubmit', turbo_frame: 'lato_operation', controller: 'lato-form' } do |form| %> ... class CustomController < ApplicationController def create_operation_action @operation = Lato::Operation.generate('OperationExampleJob', {}, @session.user_id, params[:file]) # ... end end class MyJob < Lato::ApplicationJob def perform(params = {}) save_operation_output_message("You uploaded the file #{operation_input_file_attachment.filename}") end end
----------------------------------------
Tutorial Tutorial Getting Started To create custom presentation pages for your project, you can modify the ApplicationController by extending the Lato::ApplicationController class and specifying the use of Lato's layout: class ApplicationController < Lato::ApplicationController layout 'lato/application' def index; end end How to Hide the Sidebar To hide the sidebar, you can use one of the methods provided by the Lato::Layoutable concern (already included via Lato::ApplicationController): class ApplicationController < Lato::ApplicationController layout 'lato/application' def index hide_sidebar end end To apply this rule to all controller actions, you can quickly use before_action: class ApplicationController < Lato::ApplicationController layout 'lato/application' before_action :hide_sidebar def index; end def other_action; end end How to Use Custom CSS and Customize Bootstrap To customize Lato's CSS, you can modify your main application's application.scss file: @import url('https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap'); // Override bootstrap variables $font-family-base: 'Lato' !default; $primary: #03256C; // Import Lato CSS @import 'lato/application'; // Add custom CSS pre { border-radius: 15px; } How to Use Custom Stimulus JS Controllers Stimulus JS is a dependency of Lato and can be used normally without specific integrations. Notes All controllers handled by Lato are named, by definition, lato_name_controller.js. Example: lato_hello_controller.js is used with the attribute data-controller="lato-hello". How to Protect a Page To authenticate a page and prevent public access by unauthenticated users, you can use one of the methods provided by the Lato::Sessionable concern (already included via Lato::ApplicationController): class TutorialController < ApplicationController def index return unless authenticate_session end end To apply the rule to all actions in the controller, you can simply use before_action: class TutorialController < ApplicationController before_action :authenticate_session def index; end end Notes Just like authenticate_session, you can also use its opposite not_authenticate_session to hide a page from authenticated users. Example: class AuthenticationController < ApplicationController before_action :not_authenticate_session, only: %i[signin] before_action :authenticate_session, only: %i[signout] def signin; end def signout; end end Limiting the Number of Requests To limit the number of requests to a page, you can use the limit_request method: class TutorialController < ApplicationController before_action :authenticate_session before_action :limit_request, only: %i[index] def index; end end The limit_request method accepts two parameters: limit (default: 10) and time_window (default: 10.minutes). These parameters define the maximum number of requests a user can make within a given time window. Accessing the Logged-in User The user currently logged into Lato is always accessible in all controllers and views through the @session instance of the Lato::Session model: class TutorialController < ApplicationController # ... def index @user_id = @session.user_id @user = @session.user.first_name end # ... end Notes Using @session.user_id instead of @session.user.id avoids triggering a query on the users table, improving performance! @session.valid? lets you check whether the user is logged in or not.
----------------------------------------
